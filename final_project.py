# -*- coding: utf-8 -*-
"""FINAL

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sNlbtxOWczGEcbhmqheYHlDTUJhy0FJQ
"""

# Importing a mathematical library for working with arrays and matrices - very useful in image and data processing
import numpy as np

# Library for data processing in tables – especially useful when working with data in CSV format or similar
import pandas as pd

# Library allowing access to the file system – used for reading files from folders
import os

# Anvil library – allows communication with the Web interface I built via the Anvil server
import anvil.server

# Library for drawing graphs – we will use it to plot accuracy and loss graphs during training
import matplotlib.pyplot as plt

# Additional library for drawing graphs with a slightly nicer design and ease of use
import seaborn as sns

# Library for working with Deep Learning – we will use it to define and train our model
import tensorflow as tf
from tensorflow import keras  # Part of TensorFlow that contains tools for building neural network models

# Path handling tools – allows convenient access to files according to folder locations
from pathlib import Path

# Label encoder – used to convert labels like letters into numerical representation (e.g.: 'A' -> 0)
from sklearn.preprocessing import LabelEncoder

# Image processing library – PIL is used for opening and editing graphic files
import PIL
from PIL import Image  # Image class from PIL

# More advanced library for image processing – allows, among other things, conversions, cropping, and reading images
import cv2

# Library for reading binary files – for example, an image arriving from the internet as Bytes
import io

# (Appears again) TensorFlow – already imported above, no need to import again
import tensorflow as tf

# (Appears again) LabelEncoder – already imported above
from sklearn.preprocessing import LabelEncoder

# Library for loading/saving objects to files (like a trained LabelEncoder)
import pickle

# This command installs the 'anvil-uplink' Python package in the current environment.
# The exclamation mark (!) indicates this is a shell command executed from within a Jupyter notebook or similar environment.
# 'anvil-uplink' allows the Python code to connect to an Anvil app, enabling communication between the server and the user interface.
# Installing this package is necessary before importing and using it in the Python script.

!pip install anvil-uplink

# This line establishes a connection between the Python script and the Anvil server using a unique Uplink key.
# The 'anvil.server.connect' function authenticates and links the local Python environment with the Anvil app.
# The string passed as an argument is a secret key specific to my Anvil app instance.
# Once connected, this allows the Python backend to receive calls from the Anvil frontend and respond with data or predictions.

anvil.server.connect("server_UXBWX4P55CMQDDTOHFKMMBVY-6SCAKZW3RCJCZXDE")

for dirname, _, filenames in os.walk('/content/drive/MyDrive/School/ML/DATA/drive-download-20250618T125357Z-1-001.zip (Unzipped Files)/Braille Dataset'):
    # os.walk iterates over all directories and files within the specified folder path.
    # 'dirname' is the current directory path being explored.
    # '_' is a placeholder for the list of subdirectories in the current directory (not used here).
    # 'filenames' is a list of all files in the current directory.
    for filename in filenames:
        # For each file found, print the full path by joining the directory name and the filename.
        # This helps me verify which files exist in the dataset folder before loading them.
        print(os.path.join(dirname, filename))

# This line retrieves and displays the current version of the TensorFlow library installed in the environment.
# It helps verify which TensorFlow version is being used, which is important for compatibility and debugging.
tf.__version__

# 'image_dir' is a Path object representing the directory path where the Braille dataset images are stored.
# Using 'Path' from pathlib provides an easy and reliable way to handle filesystem paths across different operating systems.
# This variable will be used later to locate and access image files for loading and processing.

image_dir = Path('/content/drive/MyDrive/School/ML/DATA/drive-download-20250618T125357Z-1-001.zip (Unzipped Files)/Braille Dataset')

# 'dir_list' is a list of all file paths in 'image_dir' that match the pattern '*.jpg'.
# The 'glob' method searches for all files with a '.jpg' extension in the specified directory.
# This list will contain the full paths to every image file to be loaded and processed later in the code.

dir_list = list(image_dir.glob('*.jpg'))

# 'image_count' stores the total number of image files found in 'dir_list'.
# The 'len()' function counts how many image paths are in the list.
# Displaying 'image_count' helps me confirm how many images are available in the dataset.

image_count = len(dir_list)
image_count

# 'name_list' is initialized as an empty list to store the labels (letters) for each image.
# The for-loop iterates over each file path in 'dir_list'.
# For each file, 'os.path.basename(i)' extracts the filename (e.g., 'a1.jpg').
# '[0]' accesses the first character of the filename, which represents the letter label of the Braille image.
# This character is appended to 'name_list', so each image has a corresponding label derived from its filename.

name_list = []
for i in dir_list:
    name_list.append(os.path.basename(i)[0])

# Initialize an empty list to store the image data arrays
images = []

# Loop through each file path in dir_list
for dir in dir_list:
    # Read the image from disk using OpenCV (cv2.imread) as a NumPy array in BGR format
    I = cv2.imread(str(dir))
    # Append the loaded image array to the images list
    images.append(I)

# Convert the list of image arrays 'images' into a single NumPy array called 'images_list'
images_list = np.array(images)

# Convert the list of labels 'name_list' into a NumPy array and transpose it (though transpose here has no effect for 1D array)
name_list = np.array(name_list).T

# Initialize a LabelEncoder instance to convert categorical labels (letters) into numerical format
le = LabelEncoder()

# Fit the LabelEncoder to 'name_list' and transform the categorical labels into numeric encoded labels
name_list = le.fit_transform(name_list)

# Normalize the pixel values of the images in 'images_list' by scaling them from [0, 255] to [0, 1]
images_list = images_list / 255.0

# Check and display the shape (dimensions)
